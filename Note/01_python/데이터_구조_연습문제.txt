다음 코드를 실행했을 때 출력되는 것은 L1 = (“orange”,”apple”,”banana”,”kiwi") new_list = i for i in L1 if len i )>5] print(new_list)
이 코드를 실행하면 SyntaxError가 발생합니다.

코드에 여러 문법 오류가 있습니다:

new_list = i for i in L1 if len i )>5] 라인에서:
리스트 컴프리헨션의 시작 대괄호 [가 빠져있음
len i )에서 여는 괄호 (가 빠져있음
len(i)가 되어야 함
올바른 코드는 다음과 같아야 합니다:

python
L1 = ("orange","apple","banana","kiwi")
new_list = [i for i in L1 if len(i) > 5]
print(new_list)
이 올바른 코드를 실행하면 출력되는 것은:

['orange', 'banana']
"orange" (길이: 6) → 5보다 크므로 포함
"apple" (길이: 5) → 5와 같으므로 제외
"banana" (길이: 6) → 5보다 크므로 포함
"kiwi" (길이: 4) → 5보다 작으므로 제외

다음 코드와 실행결과가 잘못 짝지어진 것은 ① print(list(range(10))) -- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ② print(list(range(5,10))) --[5,6,7,8,9] ③ print(list(range(10,0, 1))) --[9,8,7,6,5,4,3,2,1,0] ④ print(list(range(10,20,2))) ––[10, 12, 14, 16, 18]
잘못 짝지어진 것은 ③번입니다.

각 선택지를 분석해보면:

① print(list(range(10))) → [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ✓ (올바름)

② print(list(range(5,10))) → [5, 6, 7, 8, 9] ✓ (올바름)

③ print(list(range(10,0,1))) → [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] ✗ (잘못됨)

④ print(list(range(10,20,2))) → [10, 12, 14, 16, 18] ✓ (올바름)

③번이 잘못된 이유:

range(10, 0, 1)에서 시작값(10)이 끝값(0)보다 크고 step이 양수(1)이면, 실제로는 **빈 리스트 []**가 출력됩니다.
10에서 0까지 역순으로 가려면 step이 음수여야 합니다: range(10, 0, -1) 또는 range(9, -1, -1)이어야 합니다.
따라서 정답은 ③번입니다.

다음 구문에 의해 출력되는 것은? numbers_2d = [ [1,2,3,4,5], [10,20,30,40],[1,3,5],[2,] ] len (numbers_2d[3]
이 코드를 실행하면 SyntaxError가 발생합니다.

코드에 문법 오류가 있습니다:

len (numbers_2d[3]에서 닫는 괄호 )가 빠져있습니다.
올바른 코드는 다음과 같아야 합니다:

python
numbers_2d = [ [1,2,3,4,5], [10,20,30,40],[1,3,5],[2,] ]
len(numbers_2d[3])
만약 올바르게 작성되었다면:

numbers_2d[3]은 [2,] (네 번째 리스트)
len([2,])는 1
따라서 올바른 코드의 출력 결과는 1이지만, 주어진 코드는 괄호가 빠져서 SyntaxError가 발생합니다.


다음 코드의 실행결과가 나올 수 있는 빈칸에 들어갈 함수 이름은? numbers = [1,2,3,4,5] numbers.__([10,20,30,40,50]) numbers 결과 : [1,2,3,4,5,10,20,30,40,50]
빈칸에 들어갈 함수 이름은 **extend**입니다.

python
numbers = [1,2,3,4,5]
numbers.extend([10,20,30,40,50])
numbers
extend() 메서드의 특징:

리스트에 다른 iterable(리스트, 튜플 등)의 모든 요소를 개별적으로 추가합니다
원본 리스트를 직접 수정합니다 (in-place)
반환값은 None입니다
다른 메서드들과의 차이점:

append([10,20,30,40,50]) → [1,2,3,4,5,[10,20,30,40,50]] (리스트 전체가 하나의 요소로 추가)
extend([10,20,30,40,50]) → [1,2,3,4,5,10,20,30,40,50] (각 요소가 개별적으로 추가)
따라서 정답은 **extend**입니다.


"5. 다음 구문을 실행할 때 결과는 ?
numbers = list(range(10))
numbers[ : : 2]= [0] * len(numbers[ : :2]
print(numbers)"

이 코드를 실행하면 SyntaxError가 발생합니다.

코드에 문법 오류가 있습니다:

numbers[ : : 2]= [0] * len(numbers[ : :2]에서 마지막 괄호 )가 빠져있습니다.
올바른 코드는 다음과 같아야 합니다:

python
numbers = list(range(10))
numbers[::2] = [0] * len(numbers[::2])
print(numbers)
이 올바른 코드를 실행하면:

numbers = list(range(10)) → [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers[::2]는 [0, 2, 4, 6, 8] (짝수 인덱스 요소들)
len(numbers[::2])는 5
[0] * 5는 [0, 0, 0, 0, 0]
numbers[::2] = [0, 0, 0, 0, 0]로 짝수 인덱스 위치의 값들을 모두 0으로 변경
결과: [0, 1, 0, 3, 0, 5, 0, 7, 0, 9]

하지만 주어진 코드는 괄호가 빠져서 SyntaxError가 발생합니다.


"6. 다음 구문을 실행할 때 결과는?
numbers = [0,1,2,3,4,5,6,7,8,9]
numbers[ : : 2]= numbers[5:]
print(numbers)"

이 코드를 실행하면 ValueError가 발생합니다.

코드를 단계별로 분석해보면:

numbers = [0,1,2,3,4,5,6,7,8,9]
numbers[::2]는 [0, 2, 4, 6, 8] (짝수 인덱스의 요소들, 길이: 5)
numbers[5:]는 [5, 6, 7, 8, 9] (인덱스 5부터 끝까지, 길이: 5)
문제점: 슬라이스 할당에서 numbers[::2] = numbers[5:]를 실행하려고 하면, 좌변의 슬라이스 길이와 우변의 시퀀스 길이는 같지만, step이 1이 아닌 슬라이스 할당에서는 할당하려는 시퀀스의 길이가 정확히 일치해야 합니다.

더 중요한 것은 확장 슬라이스(extended slice) 할당에서는 우변의 길이가 좌변 슬라이스의 요소 개수와 정확히 일치해야 하는데, 이 경우 길이는 같지만 ValueError: attempt to assign sequence of size 5 to extended slice of size 5가 발생할 수 있습니다.

실제로는 이 코드는 ValueError를 발생시킵니다.

"7. 다음 구문을 실행할 때 결과는?
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers[ : : 2]= numbers[:5]
print(numbers)"

이 코드를 실행하면 다음과 같은 결과가 출력됩니다:

[0, 1, 1, 3, 2, 5, 3, 7, 4, 9]
단계별 분석:

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers[::2]는 [0, 2, 4, 6, 8] (인덱스 0, 2, 4, 6, 8의 요소들)
numbers[:5]는 [0, 1, 2, 3, 4] (처음 5개 요소)
numbers[::2] = numbers[:5]는 짝수 인덱스 위치의 값들을 [0, 1, 2, 3, 4]로 차례대로 교체:
인덱스 0: 0 → 0
인덱스 2: 2 → 1
인덱스 4: 4 → 2
인덱스 6: 6 → 3
인덱스 8: 8 → 4
최종 결과: [0, 1, 1, 3, 2, 5, 3, 7, 4, 9]
홀수 인덱스의 값들(1, 3, 5, 7, 9)은 그대로 유지되고, 짝수 인덱스의 값들만 변경됩니다.


다음 데이터에서 10 을 출력할 수 없는 구문은? my_dic = {“a”:10, “b”:20, “c”:30} ① my_dic[0] ② my_dic[‘a'] ③ list( my_dic.items ())[0][1] ④ list( my_dic.values ())[0] ⑤ my_dic.get(‘a')
10을 출력할 수 없는 구문은 **①번 my_dic[0]**입니다.

각 선택지를 분석해보면:

① my_dic[0] → KeyError 발생

딕셔너리의 키는 "a", "b", "c"이고, 숫자 0은 키로 존재하지 않음
② my_dic['a'] → 10 출력 ✓

키 'a'의 값인 10을 반환
③ list(my_dic.items())[0][1] → 10 출력 ✓

my_dic.items()는 dict_items([('a', 10), ('b', 20), ('c', 30)])
list(...)로 변환하면 [('a', 10), ('b', 20), ('c', 30)]
[0]은 첫 번째 튜플 ('a', 10)
[1]은 튜플의 두 번째 요소인 10
④ list(my_dic.values())[0] → 10 출력 ✓

my_dic.values()는 dict_values([10, 20, 30])
list(...)로 변환하면 [10, 20, 30]
[0]은 첫 번째 값인 10
⑤ my_dic.get('a') → 10 출력 ✓

get() 메서드로 키 'a'의 값인 10을 반환
따라서 정답은 ①번입니다.

다음 프로그램의 결과를 출력하시오? fruits = [ ‘apple’, ‘banana’, ‘orange’] x, y, z = fruits print(x) print(y) print(z)
이 프로그램의 결과는 다음과 같습니다:

apple
banana
orange
설명:

fruits = ['apple', 'banana', 'orange']로 리스트를 생성
x, y, z = fruits는 언패킹(unpacking) 또는 **다중 할당(multiple assignment)**으로, 리스트의 각 요소를 변수에 순서대로 할당합니다:
x = 'apple' (첫 번째 요소)
y = 'banana' (두 번째 요소)
z = 'orange' (세 번째 요소)
각 변수를 출력하면 할당된 문자열이 출력됩니다
이는 Python의 시퀀스 언패킹 기능으로, 리스트나 튜플의 요소들을 여러 변수에 한 번에 할당할 수 있습니다.


다음 프로그램의 결과를 출력하시오 fruits = [ ‘apple’, ‘banana’, ‘orange’] print( len (fruits)
이 코드를 실행하면 SyntaxError가 발생합니다.

코드에 문법 오류가 있습니다:

print( len (fruits)에서 닫는 괄호 )가 빠져있습니다.
올바른 코드는 다음과 같아야 합니다:

python
fruits = ['apple', 'banana', 'orange']
print(len(fruits))
만약 올바르게 작성되었다면 출력 결과는:

3
len(fruits)는 리스트 fruits의 요소 개수를 반환하므로, 'apple', 'banana', 'orange' 총 3개의 요소가 있어서 3이 출력됩니다.

하지만 주어진 코드는 괄호가 빠져서 SyntaxError가 발생합니다.


파이썬에서 함수를 만들기 위해 선언하는 단어는?
파이썬에서 함수를 만들기 위해 선언하는 단어는 **def**입니다.

사용법:

python
def 함수명(매개변수):
    실행할 코드
    return 반환값  # 선택사항
예시:

python
def greet(name):
    return f"안녕하세요, {name}님!"

def add(a, b):
    return a + b
def 키워드 뒤에 함수명과 괄호 안에 매개변수를 작성하고, 콜론(:)으로 함수 정의를 시작합니다.






